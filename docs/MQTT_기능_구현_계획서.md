# server2 기능 이전 및 개발 로드맵 (임시)

이 문서는 구버전 `server`의 핵심 기능을 `server2`로 이전하고, `server2`를 멀티테넌트 SaaS 플랫폼으로 완성하기 위한 단기, 중기, 장기 개발 계획을 설명합니다.

---

## 1단계: 핵심 MQTT 기능 완성 (단기 과제)

*`server2`가 최소한의 MQTT 메시지 처리 기능을 갖추고, 장치 상태 감지 기능을 강화하는 것을 목표로 합니다.*

### 작업 1.1: 다각적 장치 상태 감지 시스템 구현 (중요도: 최상)

*   **목표:** MQTT의 Keep-Alive, LWT, 그리고 Redis 기반 타임아웃 체크를 결합하여 장치의 연결 상태를 빠르고 정확하게 감지하는 시스템을 구축합니다.
*   **필요성:** 네트워크 문제, 기기 애플리케이션의 오작동 등 다양한 상황에서 기기의 상태를 정확히 파악하고 대응하기 위함입니다.
*   **세부 구현 방안:**
    1.  **애플리케이션 레벨 비활성 감지 (Redis 타임아웃 체커 구현)**
        *   **목표:** 기기 애플리케이션의 동작 중단으로 인한 비활성 상태를 감지합니다.
        *   **구현 방안:** `server2/scripts/run_device_health_checker.py` 스크립트를 생성하고, Redis Sorted Set(`device_last_seen`)을 사용하여 마지막 활동 시간이 오래된 장치를 찾아 "Timeout" 상태로 업데이트합니다. 이 스크립트를 별도 컨테이너로 실행합니다.
        *   **상태:** **구현 예정**
    2.  **네트워크 단절 감지 (MQTT LWT 구현)**
        *   **목표:** 기기의 비정상적인 네트워크 연결 끊김(예: 전원 차단)을 즉시 감지하고 "OFFLINE" 상태로 업데이트합니다.
        *   **구현 방안:**
            *   (기기 측 요구사항): 라즈베리파이 장치 연결 시, 브로커에 LWT 메시지(예: `{ "device_uuid": "...", "status": "OFFLINE" }`)와 특정 토픽(예: `device/lwt/{device_uuid}`)을 등록하도록 설정해야 합니다.
            *   (서버 측 구현): `mqtt-listener` 또는 별도 서비스에서 `device/lwt/#` 토픽을 구독하고, LWT 메시지 수신 시 해당 장치의 Redis 상태를 "OFFLINE"으로 업데이트합니다.
        *   **상태:** **미구현**
    3.  **Keep-Alive 설정 활성화**
        *   **목표:** MQTT 클라이언트와 브로커 간의 연결 유효성을 주기적으로 확인하여 LWT가 효과적으로 동작하도록 지원합니다.
        *   **구현 방안:** `EMQX` 브로커 설정 및 라즈베리파이 클라이언트(향후 개발)의 Keep-Alive 간격을 적절하게 설정합니다.
        *   **상태:** **환경 설정 필요**

### 작업 1.2: 원격 측정(Telemetry) 데이터 정규화 및 처리 로직 구현 (중요도: 높음)

*   **목표:** 프론트엔드 및 데이터 분석에 용이하도록, 중첩된 JSON 형태의 원시 데이터를 단순한 키-값 형태의 데이터로 가공(정규화)하는 로직을 구현합니다.
*   **필요성:** 현재 `processor.py`는 데이터를 가공 없이 그대로 저장하고 있어 활용성이 떨어집니다. 코드에 `TODO`로 명시되어 있습니다.
*   **구현 방안:** 구버전 `server`의 데이터 처리 로직을 분석하여 `server2`의 `processor.py` 내에 새로운 아키텍처에 맞게 재구현합니다.

### 작업 1.3: 원격 측정 데이터의 '단위(unit)' 필드 값 채우기 (중요도: 보통)

*   **목표:** 데이터베이스에 원격 측정 데이터를 저장할 때, 각 항목의 단위(예: '°C', 'V') 정보를 함께 저장하도록 구현합니다.
*   **필요성:** 데이터의 해석 및 시각화에 있어 단위 정보는 필수적입니다. 코드에 `TODO`로 명시되어 있습니다.
*   **구현 방안:** `processor.py`에서 컴포넌트의 메타데이터를 조회하여 단위 정보를 추출하고, 데이터베이스 저장 시 함께 저장하도록 수정합니다.

---

## 2단계: 핵심 비즈니스 로직 및 서비스 이전 (중기 과제)

*1단계에서 구현된 MQTT 기능 위에, 구버전 `server`의 핵심 비즈니스 로직을 이식하는 것을 목표로 합니다.*

### 작업 2.1: 데이터 무결성 검증 로직 검토 및 이전

*   **목표:** 구버전 `server`에서 수행하던 다양한 데이터 무결성 검증 로직을 `server2`로 이전합니다.
*   **필요성:** 장치로부터 수신된 데이터가 유효한지, 등록된 하드웨어 정보와 일치하는지 등을 검증하는 것은 시스템 안정성의 핵심입니다.
*   **구현 방안:** `server`의 `_process_message_task` 함수에 있던 검증 로직들(예: 하드웨어 버전 일치 여부, 등록된 컴포넌트 여부 등)을 `server2`의 `processor.py`로 이전하고, 새로운 CRUD 인터페이스에 맞게 수정합니다.

### 작업 2.2: HMAC 서명 검증 로직 강화

*   **목표:** 현재 구현된 HMAC 서명 검증 로직을 검토하고, `server2`의 보안 정책에 맞게 강화합니다.
*   **필요성:** MQTT 메시지의 무결성과 발신자 인증을 보장하는 핵심 보안 기능입니다.
*   **구현 방안:** `server2`의 `verify_hmac` 함수를 중심으로, 사용자의 `shared_secret` 관리 방식을 Vault와 연동하는 등 더 안전한 구조를 검토하고 개선합니다.

### 작업 2.3: 데이터베이스 저장 로직 (검토)

*   **목표:** `server2`의 정규화된 데이터베이스 저장 방식이 구버전 `server`의 모든 데이터 요구사항을 충족하는지 검토합니다.
*   **필요성:** 모든 수신 데이터의 영구적인 기록을 위함이며, 데이터 손실이나 호환성 문제를 방지합니다.
*   **구현 방안:** `server2`의 `telemetry_crud.create_telemetry_data` 함수가 구버전의 `crud.create_telemetry_record`를 완전히 대체하는지, 필요한 모든 필드가 저장되는지 비교 분석하고 보완이 필요한 경우 수정합니다.
