# Validator 원칙 (v1.1 - 2025.12.02 개정)

## 1. 핵심 아키텍처 원칙 ("뇌, 신경, 손/발")

Validator는 "신경"의 역할을 수행하며, 아래의 최상위 아키텍처 원칙을 반드시 준수해야 합니다.

### 1.1. Validator 독립성 원칙
- Validator는 다른 Validator를 직접 import하여 호출하거나, 그 결과에 의존해서는 안 됩니다.
- 각 Validator는 외부 의존성 없이 자신의 단일 책임을 완수하는 순수한 '신경'의 역할을 합니다.
- 여러 Validator를 조합하여 복잡한 워크플로우를 만드는 것은 오직 **`Policy` 계층(뇌)의 책임**입니다.

### 1.2. Provider를 통한 데이터 접근 원칙
- Validator는 데이터베이스에 직접 접근하거나, 다른 도메인의 `CRUD` 객체를 직접 import하여 사용해서는 안 됩니다.
- 모든 데이터 조회는 반드시 **`inter_domain` 계층에 정의된 `Provider`를 통해서만** 이루어져야 합니다.

### 1.3. 스키마/모델 참조 원칙
- Validator가 타입 힌팅 등의 목적으로 다른 도메인의 Pydantic 스키마나 SQLAlchemy 모델을 참조해야 할 경우, `services`나 `models` 계층에서 직접 import해서는 안 됩니다.
- 모든 스키마와 모델 참조는 반드시 **`inter_domain/{도메인}/schemas/` 디렉토리에 정의된 재수출(re-export) 파일을 통해서만** 이루어져야 합니다.

---

## 2. 세부 분리 원칙

하나의 Validator가 너무 많은 책임을 갖지 않도록, 아래의 세부 기준에 따라 분리합니다.

### 2.1. 실패 메시지가 다르면 → 무조건 분리
   - 예: "비밀번호가 약합니다" vs "비밀번호를 최근에 사용했습니다"
   - 이유: 프론트엔드가 다른 메시지를 보여줘야 함

### 2.2. 외부 I/O가 있으면 → 무조건 분리
   - 예: 국세청 API 호출, 비밀번호 히스토리 DB 조회
   - 이유: 성능, 장애 격리, 테스트 용이성

### 2.3. 다른 주체가 정책을 바꿀 수 있으면 → 분리 강력 권장
   - 예: 보안팀(비밀번호 강도) vs 운영팀(허용 도메인)
   - 이유: 변경 주기가 다름

### 2.4. 재사용 가능성이 30% 이상이면 → 분리 고려
   - 예: `validate_no_consecutive_chars` → 닉네임, 비밀번호 공통
   - 예외: 재사용 가능성이 있어도 의미가 완전히 다르면 합침

### 2.5. 나머지는 → 팀 컨벤션
   - 현재 컨벤션: 
     - 비밀번호 강도(길이+대소문자+숫자+특수문자+금지어)는 무조건 하나로
     - 이메일 형식 vs 도메인 허용 → 분리
     - 사업자번호 형식 vs 실존 → 분리

---

## 3. 적용 예시

| Validator 이름                     | 분리 여부 | 적용 기준 |
|------------------------------------|-----------|-----------|
| validate_password_strength         | 합침      | 2.1번 실패 메시지 동일 |
| validate_password_not_reused       | 분리      | 2.2번 외부 DB 조회 |
| validate_email_format              | 분리      | 2.1번 다른 메시지 |
| validate_email_domain_allowed      | 분리      | 2.3번 운영팀 관리 |
| validate_business_number_format    | 분리      | 2.1번 다른 메시지 |
| validate_business_number_exists    | 분리      | 2.2번 국세청 API |
